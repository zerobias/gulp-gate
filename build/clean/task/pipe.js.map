{"version":3,"names":[],"mappings":"","sources":["task/pipe.js"],"sourcesContent":["\"use strict\";\nconst R = require('ramda');\nconst gulp = require('gulp');\nconst gulpUtil = require('gulp-util');\nconst util_1 = require('../util');\nconst util_2 = require('../util');\nconst validmodel_1 = require('./validmodel');\nconst loader_1 = require('./loader');\nconst logger_1 = require('../logger');\nconst log = logger_1.Logger.initPrint('pipe');\nconst inspector = require('schema-inspector');\nconst debugPrintFabric = (name) => log.tags(['fabric type']).log(`==Fabric ${name}==`);\nclass Pipe {\n    static BatchFabric(data) {\n        let obj = data.defpath(['pipe'])(data.obj);\n        const isArray = R.when(R.is(Array), Pipe.FabricArray);\n        log.tags(['pipeFactory', 'batch', 'pipes[0]']).log(obj[0]);\n        log.tags(['pipeFactory', 'batch', 'is array?']).log(isArray(obj));\n        return isArray(obj);\n    }\n    static FabricArray(pipe) {\n        debugPrintFabric('Array');\n        return R.map(Pipe.FabricObject, pipe);\n    }\n    static FabricObject(pipe) {\n        debugPrintFabric('Object');\n        const isValidPipe = (obj) => inspector.validate(validmodel_1.ValidatorModel.Pipe, obj).valid;\n        const validPipeMaker = (_pipe) => R.when((e) => R.is(String, e.loader), R.pipe(util_1.reflectLogger((e) => log.debug('loader', loader_1.Loader.require(e.loader))), (e) => Pipe.Pipe(loader_1.Loader.require(e.loader), e.opts)))(_pipe);\n        const isExactlyOneKey = R.pipe(R.keys, R.length, R.equals(1));\n        let keys = R.keys(pipe);\n        log.tags(['pipe', 'keys', 'values']).log(`---------keys length ${keys.length} ${keys} ${R.values(pipe)}`);\n        return R.cond([\n            [isExactlyOneKey, Pipe.FabricKeypair],\n            [isValidPipe, validPipeMaker],\n            [R.is(String), Pipe.FabricString],\n            [R.T, Pipe.FabricNoop]\n        ])(pipe);\n    }\n    static FabricKeypair(pipe) {\n        debugPrintFabric('Keypair');\n        let pair = R.toPairs(pipe)[0];\n        let getLoader = loader_1.Loader.require(pair[0]);\n        return Pipe.Pipe(getLoader, pair[1]);\n    }\n    static FabricNoop() {\n        debugPrintFabric('Noop');\n        return Pipe.Pipe(gulpUtil.noop, []);\n    }\n    static FabricString(pipe) {\n        debugPrintFabric('String');\n        let resolved = loader_1.Loader.require(pipe);\n        log.debug(resolved);\n        return Pipe.Pipe(resolved, []);\n    }\n    static Pipe(loader, opts) {\n        debugPrintFabric('Pipe');\n        return {\n            loader: loader,\n            opts: util_2.isntArray(opts)\n        };\n    }\n}\nPipe.RenderPipeline = (pipeline) => R.reduce((acc, e) => e(acc), gulp.src('./source/*.styl'), R.map(Pipe.RenderPipe, pipeline));\nPipe.RenderPipe = (pipe) => (pipable) => R.when(R.is(Function), l => pipable.pipe(R.apply(l, pipe.opts)))(pipe.loader);\nexports.Pipe = Pipe;\n"],"file":"task/pipe.js","sourceRoot":"/source/"}