{"version":3,"names":[],"mappings":"","sources":["task/task.js"],"sourcesContent":["\"use strict\";\nconst gulp = require('gulp');\nconst R = require('ramda');\nconst path = require('path');\nconst pipe_1 = require('./pipe');\nconst validmodel_1 = require('./validmodel');\nconst inspector = require('schema-inspector');\nclass TaskPreproc {\n    static Morph(data) {\n        let task = data.task;\n        task.name = TaskPreproc.NameFabric(data);\n        task.filemask = TaskPreproc.FilemaskFabric(data);\n        task.dir = TaskPreproc.DirFabric(data);\n        task.taskOpts = TaskPreproc.TaskOptsFabric(data);\n        task.pipes = TaskPreproc.PipesFabric(data);\n    }\n    static NameFabric(data) {\n        const makeFullName = (subname, taskname) => [subname, taskname].join(':');\n        return {\n            short: data.taskname,\n            full: makeFullName(data.subname, data.taskname)\n        };\n    }\n    static pathMaker(dirs) {\n        return R.pipe(R.prepend(process.cwd()), R.apply(path.join))(dirs);\n    }\n    static FilemaskFabric(data) {\n        let ext = data.defpath(['include', 'ext']);\n        let filename = (_ext, name) => [name ? name : '*', _ext].join('.');\n        let deep = R.pathOr(false, ['include', 'deep']);\n        let result = R.pipe(ext, filename, R.of);\n        return R.ifElse(deep, R.pipe(result, R.prepend('**')), result)(data.obj);\n    }\n    static DirFabric(data) {\n        let defPath = (target) => data.defpath(['dir', target])(data.obj);\n        let pathArray = (target, targetFolder) => [\n            targetFolder\n                ? targetFolder\n                : target,\n            data.subname,\n            defPath(target)\n        ];\n        return {\n            source: TaskPreproc.pathMaker(R.concat(pathArray('source'), data.task.filemask)),\n            dest: TaskPreproc.pathMaker(pathArray('dest', 'build'))\n        };\n    }\n    static TaskOptsFabric(data) {\n        return inspector.sanitize(validmodel_1.ValidatorModel.TaskOpts, R.propOr({}, 'taskOpts', data.obj)).data;\n    }\n}\nTaskPreproc.PipesFabric = (data) => pipe_1.Pipe.BatchFabric(data);\nclass FullTask {\n    constructor(subname, taskname, obj) {\n        this.subname = subname;\n        this.taskname = taskname;\n        this.obj = obj;\n        this.rendered = false;\n        TaskPreproc.Morph(this.Adapter);\n    }\n    get Adapter() {\n        return {\n            taskname: this.taskname,\n            subname: this.subname,\n            obj: this.obj,\n            defpath: R.pathOr(this.taskname),\n            task: this\n        };\n    }\n    static get dest() {\n        return gulp.dest('./build/magic');\n    }\n    get _render() {\n        const thisRender = () => {\n            let pipes = pipe_1.Pipe.RenderPipeline(this.pipes);\n            gulp.task(this.name.full, function () { return pipes.pipe(FullTask.dest); });\n            this.rendered = true;\n            return pipes;\n        };\n        const onceRender = R.once(thisRender);\n        return onceRender();\n    }\n    get uid() {\n        return this.name.full;\n    }\n    render() {\n        return this._render;\n    }\n    run() {\n        if (!this.rendered)\n            this.render();\n        return gulp.start([this.name.full]);\n    }\n}\nexports.FullTask = FullTask;\n"],"file":"task/task.js","sourceRoot":"/source/"}